<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SiriShortcut和NSUserActivity]]></title>
    <url>%2Fhexo%2F2019%2F05%2F31%2FSiriShortcut%E5%92%8CNSUserActivity%2F</url>
    <content type="text"><![CDATA[Siri Shortcut &amp;&amp; NSUserActivity可以做什么 通过Siri，说出预先自定义的语音，进入到app，完成相关动作 iOS12 之后，NSUserActivity可以用于SiriKit ShortCuts，通过自定义语音唤起App完成相关动作用户必须进入过相关界面，并且添加自定义语音到SiriDemo ：feature/SiriShortcut 借条可用，快速进入CheckSystemInfo界面 代码实现 iOS 12之后 添加plist，加入NSUserActivityTypes，数组类型，加入自定义的UserActivityTypes 添加add to Siri按钮，这里使用系统定义的INUIAddVoiceShortcutButton，自定义的话文章后面有介绍12345678910111213141516171819202122232425262728293031323334353637383940414243//添加按钮- (void)addVoiceShortcutButton &#123; if (@available(iOS 12.0, *)) &#123; //此按钮可以自行判断shortcut中的userActivity是否已经添加过，从而显示不同的样式 INUIAddVoiceShortcutButton *voiceBtn = [[INUIAddVoiceShortcutButton alloc] initWithStyle:INUIAddVoiceShortcutButtonStyleWhiteOutline]; voiceBtn.shortcut = [[INShortcut alloc] initWithUserActivity:[self createRelevantUserActivity]]; //按钮点击事件的代理 voiceBtn.delegate = self; voiceBtn.translatesAutoresizingMaskIntoConstraints = NO; //按钮需要约束布局，测试设置frame无效 UIView *bottomView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, UXY_SCREEN_WIDTH, 400)]; [bottomView addSubview:voiceBtn]; [[bottomView.centerXAnchor constraintEqualToAnchor:voiceBtn.centerXAnchor] setActive:YES]; [[bottomView.centerYAnchor constraintEqualToAnchor:voiceBtn.centerYAnchor] setActive:YES]; self.tableView.tableFooterView = bottomView; &#125;&#125;//创建相关userActivity- (NSUserActivity *)createRelevantUserActivity &#123; NSUserActivity *activity = [[NSUserActivity alloc] initWithActivityType:@&quot;com.qihoo.corp.loan.checksysteminfo&quot;]; //显示在siri 建议或者core spotlight 中的标题 activity.title = @&quot;版本信息&quot;; //core spotlight关键词，和siri无关 activity.keywords = [NSSet setWithArray:@[@&quot;版本信息&quot;,@&quot;查看版本&quot;]]; //携带的用户信息 activity.userInfo = @&#123;@&quot;qihoo&quot;:@&quot;checksysteminfo&quot;&#125;; //开启用于检索 activity.eligibleForSearch = YES; //ios12 sirikit if (@available(iOS 12.0, *)) &#123; //开启sirikit activity.eligibleForPrediction = YES; //建议语句，会显示在添加Siri捷径的界面中 activity.suggestedInvocationPhrase = @&quot;查看版本&quot;; &#125; //其他相关显示信息，不了解可以查看core spotlight一文 CSSearchableItemAttributeSet *set = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:@&quot;com.qihoo.corp.loan.checksysteminfo&quot;]; set.contentDescription = @&quot;检查应用的版本信息&quot;; activity.contentAttributeSet = set; //启用core spotlight，不使用的话可以删掉 self.userActivity = activity; return activity;&#125; 按钮添加前后样式如下，需要实现代理完成不同的跳转userActivity未加入到Siri的状态 userActivity已经加入到Siri的状态 实现INUIAddVoiceShortcutButtonDelegate代理 1234567891011121314#pragma mark - INUIAddVoiceShortcutButtonDelegate//新添加- (void)presentAddVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)addVoiceShortcutViewController forAddVoiceShortcutButton:(INUIAddVoiceShortcutButton *)addVoiceShortcutButton API_AVAILABLE(ios(12.0))&#123; //新添加界面的代理 addVoiceShortcutViewController.delegate = self; [self presentViewController:addVoiceShortcutViewController animated:YES completion:nil]; &#125;//添加过，去编辑- (void)presentEditVoiceShortcutViewController:(INUIEditVoiceShortcutViewController *)editVoiceShortcutViewController forAddVoiceShortcutButton:(INUIAddVoiceShortcutButton *)addVoiceShortcutButton API_AVAILABLE(ios(12.0))&#123; //编辑界面的代理 editVoiceShortcutViewController.delegate = self; [self presentViewController:editVoiceShortcutViewController animated:YES completion:nil];&#125; 跳转不同的界面也有不同的代理 新添加界面的代理INUIAddVoiceShortcutViewControllerDelegate 123456789101112131415161718#pragma mark - INUIAddVoiceShortcutViewControllerDelegate- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(nullable INVoiceShortcut *)voiceShortcut error:(nullable NSError *)error API_AVAILABLE(ios(12.0))&#123; if (!error) &#123; NSLog(@&quot;%@, %@&quot;, voiceShortcut.invocationPhrase, voiceShortcut.identifier); [controller dismissViewControllerAnimated:YES completion:^&#123; NSLog(@&quot;添加成功&quot;); &#125;]; &#125; else &#123; NSLog(@&quot;%@&quot;, error.localizedDescription); &#125;&#125;- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller API_AVAILABLE(ios(12.0))&#123; [controller dismissViewControllerAnimated:YES completion:^&#123; NSLog(@&quot;取消添加&quot;); &#125;];&#125; 已添加，编辑界面代理 123456789101112131415161718192021222324#pragma mark - INUIEditVoiceShortcutViewControllerDelegate- (void)editVoiceShortcutViewController:(INUIEditVoiceShortcutViewController *)controller didUpdateVoiceShortcut:(nullable INVoiceShortcut *)voiceShortcut error:(nullable NSError *)error API_AVAILABLE(ios(12.0))&#123; if (!error) &#123; NSLog(@&quot;%@, %@&quot;, voiceShortcut.invocationPhrase, voiceShortcut.identifier); [controller dismissViewControllerAnimated:YES completion:^&#123; NSLog(@&quot;修改成功&quot;); &#125;]; &#125; else &#123; NSLog(@&quot;%@&quot;, error.localizedDescription); &#125;&#125;- (void)editVoiceShortcutViewController:(INUIEditVoiceShortcutViewController *)controller didDeleteVoiceShortcutWithIdentifier:(NSUUID *)deletedVoiceShortcutIdentifier API_AVAILABLE(ios(12.0))&#123; [controller dismissViewControllerAnimated:YES completion:^&#123; NSLog(@&quot;删除指令&quot;); &#125;];&#125;- (void)editVoiceShortcutViewControllerDidCancel:(INUIEditVoiceShortcutViewController *)controller API_AVAILABLE(ios(12.0))&#123; [controller dismissViewControllerAnimated:YES completion:^&#123; NSLog(@&quot;取消添加&quot;); &#125;];&#125; AppDelegate中处理跳转信息1234567891011- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123; //Siri Shortcut相关 if ([userActivity.activityType isEqualToString:@&quot;com.qihoo.corp.loan.checksysteminfo&quot;]) &#123; NSString *resourceBundle = [[NSBundle mainBundle] pathForResource:@&quot;qihooloan_res&quot; ofType:@&quot;bundle&quot;]; UIStoryboard *board = [UIStoryboard storyboardWithName:@&quot;MainSDK&quot; bundle:[NSBundle bundleWithPath:resourceBundle]]; UIViewController *vc = [board instantiateViewControllerWithIdentifier:@&quot;CheckSystemInfoViewController&quot;]; [[UIWindow uxy_optimizedVisibleViewController].navigationController pushViewController:vc animated:YES]; &#125; return YES;&#125; 自定义Siri按钮及跳转123456789101112131415161718192021222324//判断 可以自定义添加到Siri按钮- (void)isVoiceShortcutExist &#123; //回调再子线程，如操作UI需要回到主线程 if (@available(iOS 12.0, *)) &#123; [[INVoiceShortcutCenter sharedCenter] getAllVoiceShortcutsWithCompletion:^(NSArray&lt;INVoiceShortcut *&gt; * _Nullable voiceShortcuts, NSError * _Nullable error) &#123; if (!error) &#123; for (INVoiceShortcut *shortcut in voiceShortcuts) &#123; //存在 if ([shortcut.shortcut.userActivity.activityType isEqualToString:@&quot;com.qihoo.corp.loan.checksysteminfo&quot;]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; //添加一个按钮，可以点击跳转INUIEditVoiceShortcutViewController，INUIEditVoiceShortcutViewController需要自己生成 &#125;); &#125; else &#123; //不存在 dispatch_async(dispatch_get_main_queue(), ^&#123; //添加一个按钮，可以点击跳转INUIAddVoiceShortcutViewController，INUIAddVoiceShortcutViewController需要自己生成 &#125;); &#125; &#125; &#125; &#125;]; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>siriShortcut</tag>
        <tag>NSUserActivity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreSpotlight使用总结]]></title>
    <url>%2Fhexo%2F2019%2F05%2F31%2FCoreSpotlight%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Core Spotlight 搜索可以做什么？ 在手机全局搜索中输入搜索关键词，出现自定义搜索相关项，点击完成相关操作（拨打电话、导航、携带相关信息进入app完成操作） 增加App曝光率，易于集成操作。 要求 iOS9 最好在子线程创建索引，索引数量在数千级别之下，太多会影响性能 默认失效日期为一个月，可以自行设置 集成优势 Api简单，模块独立，方便从H5调用本地Api进行索引的创建，修改，删除。 代码实现 导入框架 1#import &lt;CoreSpotlight/CoreSpotlight.h&gt; 创建CSSearchableItem，每一个CSSearchableItem对应一个搜索项 CSSearchableItemAttributeSet为Item的属性set， title：展示标题 contentDescription：展示内容 rating：星评分数 thumbnailData：展示图片，不设置的话默认为AppIcon contactKeywords：搜索关键词，title也可以用于搜索 supportsNavigation：开启支持导航，latitude，longitude经纬度 supportsPhoneCall：开启支持通话，phoneNumbers通话号码 CSSearchableItem的属性 uniqueIdentifier：唯一标识符 domainIdentifier：域标识符，相当于所属文件夹 expirationDate：失效时间，默认一个月 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** 基本搜索展示 @return CSSearchableItem */- (CSSearchableItem *)basicCoreSpotlight &#123; CSSearchableItemAttributeSet *set = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:@&quot;Qihoo&quot;]; //显示标题 set.title = @&quot;我是Title&quot;; //显示内容 set.contentDescription = @&quot;我是Description&quot;; //搜索关键词 标题也可以用于搜索 set.contactKeywords = @[@&quot;360&quot;,@&quot;贷款&quot;,@&quot;没钱&quot;]; //每一个CSSearchableItem对应一个搜索项 CSSearchableItem *item = [[CSSearchableItem alloc] initWithUniqueIdentifier:@&quot;basic&quot; domainIdentifier:@&quot;com.liang&quot; attributeSet:set]; //过期时间 item.expirationDate = [NSDate dateWithTimeIntervalSinceNow:10 * 24 * 3600]; return item;&#125;/** 图片星评展示 @return CSSearchableItem */- (CSSearchableItem *)imageRateCoreSpotlight &#123; CSSearchableItemAttributeSet *set = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:@&quot;Qihoo&quot;]; set.title = @&quot;我是Title&quot;; set.contentDescription = @&quot;我是Description&quot;; //星评 set.rating = @(3.5); //展示图片，不设置的话默认AppIcon set.thumbnailData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;money&quot;]); set.contactKeywords = @[@&quot;360&quot;,@&quot;贷款&quot;,@&quot;没钱&quot;]; CSSearchableItem *item = [[CSSearchableItem alloc] initWithUniqueIdentifier:@&quot;image&quot; domainIdentifier:@&quot;com.liang&quot; attributeSet:set]; //过期时间 item.expirationDate = [NSDate dateWithTimeIntervalSinceNow:10 * 24 * 3600]; return item;&#125;/** 导航 @return CSSearchableItem */- (CSSearchableItem *)locationCoreSpotlight &#123; CSSearchableItemAttributeSet *set = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:@&quot;Qihoo&quot;]; set.title = @&quot;我是Title&quot;; set.contentDescription = @&quot;我是Description&quot;; set.thumbnailData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;location&quot;]); //开启导航 set.supportsNavigation = @(YES); //导航目的地 set.latitude = @(22.571561); set.longitude = @(114.059831); //搜索关键词 set.contactKeywords = @[@&quot;360&quot;,@&quot;贷款&quot;,@&quot;没钱&quot;]; CSSearchableItem *item = [[CSSearchableItem alloc] initWithUniqueIdentifier:@&quot;location&quot; domainIdentifier:@&quot;com.liang&quot; attributeSet:set]; //过期时间 item.expirationDate = [NSDate dateWithTimeIntervalSinceNow:10 * 24 * 3600]; return item;&#125;/** phoneCall @return CSSearchableItem */- (CSSearchableItem *)phoneCallCoreSpotlight &#123; CSSearchableItemAttributeSet *set = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:@&quot;Qihoo&quot;]; set.title = @&quot;我是Title&quot;; set.contentDescription = @&quot;我是Description&quot;; set.thumbnailData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;phoneCall&quot;]); //开启支持通话 set.supportsPhoneCall = @(YES); //通话号码 set.phoneNumbers = @[@&quot;10086&quot;]; //搜索关键词 set.contactKeywords = @[@&quot;360&quot;,@&quot;贷款&quot;,@&quot;没钱&quot;]; CSSearchableItem *item = [[CSSearchableItem alloc] initWithUniqueIdentifier:@&quot;phoneCall&quot; domainIdentifier:@&quot;com.liang&quot; attributeSet:set]; //过期时间 item.expirationDate = [NSDate dateWithTimeIntervalSinceNow:10 * 24 * 3600]; return item;&#125; 将创建的CSSearchableItem加入到系统索引中，然后在系统的搜索栏中搜索关键字就可以找到创建的item 12345678910NSArray *items = @[[self basicCoreSpotlight],[self imageRateCoreSpotlight],[self locationCoreSpotlight],[self phoneCallCoreSpotlight]]; CSSearchableIndex *index = [CSSearchableIndex defaultSearchableIndex]; //更新，添加索引项 [index indexSearchableItems:items completionHandler:^(NSError * _Nullable error) &#123; if (!error) &#123; NSLog(@&quot;success&quot;); &#125; else &#123; NSLog(@&quot;error : %@&quot;,error); &#125; &#125;]; 删除索引 12345678910111213141516171819202122232425CSSearchableIndex *index = [CSSearchableIndex defaultSearchableIndex]; //按统一标识符删 [index deleteSearchableItemsWithIdentifiers:@[@&quot;basic&quot;] completionHandler:^(NSError * _Nullable error) &#123; if (!error) &#123; NSLog(@&quot;success&quot;); &#125; else &#123; NSLog(@&quot;error : %@&quot;,error); &#125; &#125;]; //按域名删 [index deleteSearchableItemsWithDomainIdentifiers:@[@&quot;Qihoo&quot;] completionHandler:^(NSError * _Nullable error) &#123; if (!error) &#123; NSLog(@&quot;success&quot;); &#125; else &#123; NSLog(@&quot;error : %@&quot;,error); &#125; &#125;]; //删除所有 [index deleteAllSearchableItemsWithCompletionHandler:^(NSError * _Nullable error) &#123; if (!error) &#123; NSLog(@&quot;success&quot;); &#125; else &#123; NSLog(@&quot;error : %@&quot;,error); &#125; &#125;]; 点击CoreSpotlight中的item，完成通话，导航或者挑战App继续完成相关动作 12345678910111213141516171819//点击CSSearchableItem进入会出发AppDelegate的这个方法，相关CSSearchableItem信息被封装在NSUserActivity中- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123; NSString *idetifier = userActivity.userInfo[CSSearchableItemActivityIdentifier]; NSLog(@&quot;idetifier : %@&quot;,idetifier); NSString *activityType = userActivity.activityType; NSLog(@&quot;activityType : %@&quot;,activityType); // 根据 activityType、idetifier 识别索引 if ([idetifier isEqualToString:@&quot;basic&quot;]) &#123; //do Something &#125; else if ([idetifier isEqualToString:@&quot;image&quot;])&#123; //do Something &#125; else if ([idetifier isEqualToString:@&quot;location&quot;]) &#123; //do Something &#125; else if ([idetifier isEqualToString:@&quot;phoneCall&quot;]) &#123; //do Something &#125; return YES;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>coreSpotlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SiriKit个人使用总结]]></title>
    <url>%2Fhexo%2F2019%2F05%2F31%2FSiriKit%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[SiriKit可以做什么？ SiriKit在iOS10之后开放给开发者，在iOS12有进行了一次功能提升 iOS12之前的Siri 使用Siri说出相关希望App完成的动作，例如：“微信发送信息你好给小柔”，则Siri会调用微信的SiriExtension完成相关操作。 如果SiriExtension无法完成，Siri会提示用户打开应用完成相关动作。（这一步需要用户手动点击，可以携带相关信息进入，有App继续完成） 想要调起App的SiriExtension，用户的语音指令必须为SiriKit定义的domain中的一种，且开发者必须实现相应domain处理，否则Siri无法根据开发者定义的功能完成上述两种操作。后续操作完全由Siri去解析执行，和App无关。domain定义了SiriKit支持处理的事件范围： 语音视频通话 发送消息 付款 笔记 视觉编码 图片搜索 锻炼管理 行程预约 车载管理 餐厅定位 iOS12后的Siri iOS12后，Siri提供了自定义语音意图功能，不再受限于之前的domain。用户通过这个自定义功能添加语音到Siri完成相关功能。 SiriKit简介 iOS 10.0+ macOS 10.12+ watchOS 3.2+ iOS 10之后，Apple开放了SiriKit框架，用于通过Siri更加方便用户操作App相关功能。 用户向Siri发送语音指令，Siri将此指令解析为Intent对象，发送给相关联的App Extentsion。Extension根据Intent执行相关操作，完成用户指令。相关操作可以通过Intent UI Extentsion展示在Siri中。 所有语音解析由Siri完成，Siri将解析后的用户指令封装为Intent对象发送给相应的App Extension程序。 Intent UI Extension提供交互中展示在Siri中的UI界面，可以增强用户体验，为可选项。 Siri将可以解析并完成的Intent划分到不同的域（domain）中，包含以下几种： 域（domain） 对应的意图（Intent） Messaging：发送消息或者查找用户接收到的消息 INSendMessageIntent Lists and Notes：创建和管理备注和待办事项列表项。 INCreateNoteIntent、INAppendToNoteIntent Workout：开始、结束和管理健身事项 INEndWorkoutIntent、INPauseWorkoutIntent 、INStartWorkoutIntent 、 INResumeWorkoutIntent 、INCancelWorkoutIntent Payments：在用户之间发送付款或支付账单 INSendPaymentIntent、INRequestPaymentIntent VoIP Calling：发起VoIP通话，或者查找通话历史 INSearchCallHistoryIntent、INStartAudioCallIntent、INStartVideoCallIntent Visual Codes：视觉编码 INGetVisualCodeIntent Photos：图片搜索 INSearchForPhotosIntent Ride booking：行程预约 INRequestRideIntent、INGetRideStatusIntent、 INListRideOptionsIntent、 INGetRideStatusIntent Car Commands：车载管理 INGetCarLockStatusIntent、INSetCarLockStatusIntent、INActivateCarSignalIntent Car Play：车载系统 INSetAudioSourceInCarIntent、 INSetClimateSettingsInCarIntent、 INSetSeatSettingsInCarIntent、INSaveProfileInCarIntent、INSetProfileInCarIntent、INSetRadioStationIntent Restaurant Reservations： INBookRestaurantReservationIntent、 INGetAvailableRestaurantReservationBookingDefaultsIntent、 INGetAvailableRestaurantReservationBookingsIntent、 INGetRestaurantGuestIntent、 INGetUserCurrentRestaurantReservationBookingsIntent Siri完成语音识别和语义分析； 根据你词汇中的关键词识别出你属于上述11种域（domain）中的哪一种； 然后将结构化语音分析结果打包成一个某个域（Domain）的意图(Intent)； 接着交给支持这个意图（Intent）的第三方App Extension，App Extension启动，从传入的Intent中获取相应的信息，完成操作。 SiriKit集成 开启Siri Capabilities。必须要有付费开发者账号，未付费开发者无此选项。 请求Siri权限。 12345678910 //请求Siri权限- (void)requestingAuthorizationToUseSiriKit &#123; [INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) &#123; if (status == INSiriAuthorizationStatusAuthorized) &#123; &#125; else &#123; &#125; &#125;];&#125; ![Siri权限描述](http://image.liangqili.com/SiriKit/Siri_description.png) 添加Extension，添加Intents Extension，Xcode会附带提示是否添加Intents UI Extentsion（可选）。 配置对应Target的info.plist。plist文件中包含一个NSExtension字段，里面包含对应的配置; |key|value| |—|—–| |NSExtensionPointIdentifier|com.apple.intents-service（固定值）| |NSExtensionPrincipalClass|入口文件，首先相应Siri请求的文件| |NSExtensionAttributes|包含两个值：IntentsRestrictedWhileLocked锁屏状态下禁止的域；IntentsSupported支持的域；域为上面介绍的11种类型中的一个或多个| SiriKit处理流程Siri解析出相关信息封装为Intent类型，通过plist中配置的入口文件找到相关类的- (id)handlerForIntent:(INIntent *)intent方法，询问具体处理事件的类 123456789101112131415// 这里是SiriExtension的入口，判断意图类型- (id)handlerForIntent:(INIntent *)intent &#123; // 如果是INSendMessageIntent，使用自定义的SendMessageIntentHandler处理 if ([intent isKindOfClass:[INSendMessageIntent class]]) &#123; SendMessageIntentHandler *SendMsgHandler = [[SendMessageIntentHandler alloc] init]; return SendMsgHandler; // 如果是INSendPaymentIntent，使用自定义的SendPaymentIntentHandler处理 &#125;else if ([intent isKindOfClass:[INSendPaymentIntent class]]) &#123; SendPaymentIntentHandler *SendPayHandler = [[SendPaymentIntentHandler alloc] init]; return SendPayHandler; //其他的自己处理 &#125;else &#123; return self; &#125;&#125; 找到相应的处理类之后，进入事件处理流程，以INSendMessageIntent为例。 相关处理方法如下： 123456789101112//确认消息发送对象- (void)resolveRecipientsForSendMessage:(INSendMessageIntent *)intent withCompletion:(void (^)(NSArray&lt;INPersonResolutionResult *&gt; *resolutionResults))completion &#123;&#125;// 确认消息发送内容- (void)resolveContentForSendMessage:(INSendMessageIntent *)intent withCompletion:(void (^)(INStringResolutionResult *resolutionResult))completion &#123;&#125; //确认是否可以发送（例如权限鉴定）- (void)confirmSendMessage:(INSendMessageIntent *)intent completion:(void (^)(INSendMessageIntentResponse *response))completion &#123;&#125; // 处理方法，处理发送信息逻辑- (void)handleSendMessage:(INSendMessageIntent *)intent completion:(void (^)(INSendMessageIntentResponse *response))completion &#123;&#125; Intent UI对于支持自定义界面的 Intent 类型，可以在 Intents UI Extension 中提供更美观的自定义界面。 Custom UI 的实现相对较简单，和 iOS App 的开发一样，都是通过 UIViewController 的子类实现。我们需要在 Intents UI Extension 的 info.plist 文件中设置 initial viewcontroller 或者设置 main storyboard，对于不同类型的 Intent 的界面展示，通过 Child Viewcontrollers 的方式实现差异化界面展示。 当接收到来自 Intents Extension 的 response 时，系统会唤起 Intents UI Extension 并加载 initial viewcontroller，通过INUIHostedViewSiriProviding协议的configureWithInteraction:context:completion:方法可以获取 intent，比如在发消息功能中，在消息确认发送和发送成功后都会回调一次这个方法。根据 Intent 对象的类型和状态，在收到相关 Intent 的回调时 present 对应的 Child Viewcontroller 即可实现定制化的界面展示。 这里需要注意的是，Intents UI Extension 的进程并不会在界面销毁后就退出，很可能只是在后台处于休眠状态，下次 response 到来时再被唤醒。 文献：官方文档iOS 10 SiriKit QQ 适配详解SiriKit预研]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>siriKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hellow World]]></title>
    <url>%2Fhexo%2F2019%2F05%2F11%2FHellow-World%2F</url>
    <content type="text"><![CDATA[倒腾了很久，终于把个人网站门面弄得七七八八了，第一篇文章记录下本站的降临。不会叙述的特别详细，因为大部分资料网上都有，大致写下流程，记录下踩得坑。 服务器购买在阿里云买了一台服务器，用于个人站点的载体，镜像选择的是Ubuntu，期间有用过Windows Server，但是木有命令行操作的快感，所有又换了回来。镜像阿里云会自带的有，具体操作也有相关描述，没有什么难点，需要记住分配的公网IP地址，用于域名映射。 域名购买考虑到使用的方便，又花了几百大洋，在腾讯云购买了同名域名www.liangqili.com，个人账号需要实名认证，域名需要备案。这里有个操作需要注意，就是要将域名解析到服务器，这样才能通过域名访问到服务器。在域名管理里面，下载证书，用于后期搭建https服务。 SSL证书申请后续准备使用https服务，需要申请SSL证书。腾讯云有免费证书可以申请，按照步骤申请，绑定已经申请的域名，并下载证书，留存后用。 服务器配置完成以上的前期工作，接下来就需要进行服务器搭建工作。 ssh链接服务器ssh链接Ubuntu进行搭建工作 安装transmit因为需要和服务器传输相关文件，需要启用FTP客户端服务，本人使用的是Mac，所以推荐使用一款好用的FTP客户端图形操作软件：transmit，操作比较简单，网上有教程 服务器选型Nginx、Apache2均可，我这里选择使用Apache2作为服务器 首先更新下Ubuntu系统软件 123sudo apt-get update # 获取最新资源包 sudo apt-get upgrade # 本机软件全部更新 sudo apt-get dist-upgrade # 本机系统软件更新 安装LAMP万能服务端环境 1sudo apt-get install lamp-server^ #不要忘记^ 等待安装完成，过程不难，如有问题，百度谷歌一下。安装完成之后，需要进行Apache2服务器配置，比如设置网站根目录，开启PHP等等，网上有很多资料，配置比较容易。附一份参考过的文章：ubuntu apache2服务器配置完成以上配置，就可以在浏览器中输入www.liangqili.com进行访问了。 配置HTTPS服务推荐使用https访问个人网站，否则Chrome浏览会显示不安全的标识，强迫症受不了。所以需要在服务端启用https，并将http请求重定向到https。 安装证书，启用SSL相关参考：证书安装指引 在apache2目录下新建ssl目录，将下载的证书放入 12root@iZ85qvl6le56fhZ:/etc/apache2/ssl# ls1_root_bundle.crt 2_www.liangqili.com.crt 3_www.liangqili.com.key 开启SSL 1234#开启SSL模块a2enmod ssl #启用SSL站点a2ensite default-ssl /etc/apache2/ports.conf 监听443端口 12345678910111213# If you just change the port or add more ports here, you will likely also# have to change the VirtualHost statement in# /etc/apache2/sites-enabled/000-default.confListen 80&lt;IfModule ssl_module&gt; Listen 443&lt;/IfModule&gt;&lt;IfModule mod_gnutls.c&gt; Listen 443&lt;/IfModule&gt; 配置SSL证书，根目录，在/etc/apache2/sites-enabled/default-ssl.conf 1234567ServerName www.liangqili.comDocumentRoot /var/www/htmlSSLEngine onSSLCertificateFile /etc/apache2/ssl/2_www.liangqili.com.crtSSLCertificateKeyFile /etc/apache2/ssl/3_www.liangqili.com.keySSLCertificateChainFile /etc/apache2/ssl/1_root_bundle.crt 重启apache2即可使用https访问站点。 将http重定向到https，这里使用.htaccess文件在站点根目录下添加.htaccess文件，编辑文件，输入以下内容，保存 123RewriteEngine onRewriteCond %&#123;SERVER_PORT&#125; 80RewriteRule ^(.*)$ https://www.liangqili.com/$1 [R,L] 重启apache2服务，用http访问站点，即可发现，自动切换为https 至此，服务器已经搭建完毕，下面进行hexo博客搭建 Hexo博客搭建参考文档：hexo官方文档hexo依赖于nodejs和git，需要提前安装，安装完成后，使用npm安装hexo 1npm install -g hexo-cli hexo相关操作没有难度，说明文档里面都有，这里记录下遇到的问题。 Error: EACCES: permission deniednpm安装hexo报错Error: EACCES: permission denied，即使加上sudo也无效，nodejs官方文档找到以下解决方法，尝试有效： 1234mkdir ~/.npm-globalnpm config set prefix &apos;~/.npm-global&apos;export PATH=~/.npm-global/bin:$PATHsource ~/.profile 参考文档：官方文档解决方案链接地址 npm换源遇到npm很慢的情况，考虑将npm源换到taobao镜像。 1npm config set registry https://registry.npm.taobao.org 切换回原始镜像 1npm config set registry https://registry.npmjs.org/ 查看npm源 1npm config get registry 参考文档：淘宝npm镜像 ssh配置公私钥快速链接经常使用ssh 链接服务器或者使用git push代码，需要输入密码很麻烦，可以为ssh添加公私钥免登陆密码，避免提交git时候输入密码。网上有很多教程，操作比较简单。参考链接：github添加ssh hexo部署到自己的服务器很多人将自己的hexo博客主页部署到github，不过有了自己的服务器，就决定将博客部署到github和自己的云服务器参考文档：在 Ubuntu 服务器部署 hexo 搭建个人博客 本地 hexo 博客配置一个部署静态文件的远程仓库 123456sudo mkdir /var/repo/sudo mkdir /var/repo/sudo chown -R $USER:$USER /var/repo/sudo chmod -R 755 /var/repo/cd /var/repogit init --bare hexoBlog.git apache2网站根目录下创建一个hexo，用于部署博客(网上很多教程将hexo部署为个人网站的主页，我这里只是作为了一个二级界面) 1sudo mkdir -p /var/www/html/hexo 创建 Git 钩子，将hexo远程仓库的文件，同步一份到apache2 123sudo vim /var/repo/hexoBlog.git/hooks/post-receivegit --work-tree=/var/www/html/hexo --git-dir=/var/repo/hexoBlog.git checkout -fchmod +x /var/repo/hexoBlog.git/hooks/post-receive #添加可执行权限 修改hexo配置文件，将博客deploy到云服务器（同时也可以将博客deploy到github） 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:lifeasy/lifeasy.github.io.git branch: master- type: git repo: root@47.106.123.122:/var/repo/hexoBlog branch: master 如果配置了ssh key，就不用输入密码，如果没有，则需要输入密码 另外需要注意的是博客的根目录问题，因为的我的网站的hexo在二级目录，所以需要重新修改配置文件，否则网页会因为资源文件的问题显示不正确。这里我用了两份配置，一份用于上传github，一份用于上传个人服务器，配合上面的deploy使用。目前这种操作还输入手动方式，后续看看是否有其他更加自动化的方式。 123456789101112# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://www.liangqili.com/hexoroot: /hexo/permalink: :year/:month/:day/:title/permalink_defaults:#上传到git.io 根目录不同，需要单独配置# url: https://lifeasy.github.io# root: /# permalink: :year/:month/:day/:title/# permalink_defaults: 多地同步编辑hexo博客因为不可能在一台机器上书写博客，所以考虑将博客同步到github，然后另一台机器也可以clone下来，进行编辑。操作比较简单，这里简单概述下： github创建一个仓库用于存储hexo文档（非github.io） clone到本地，将hexo文件夹拖到此仓库，在hexo中新建.gitignore文件，过滤掉无关文件（可生成文件），原理同Xcode项目只上传Podfile和Podfile.lock文件类似，不过在另一端同步到文件后，需要重新执行hexo clean`hexo g`，这里需要注意的是theme，因为这也是一个git，为了避免冲突，需要将theme下的.git删除 1234567.DS_Store #mac系统文件 无视Thumbs.db #mac系统文件 无视db.json*.lognode_modules/public/.deploy*/ hexo博客书写参考文档：hexo官方文档包含hexo的常规操作，生成tags、categorie、404等等，相关操作查看hexo官方文档。注意因为有些参考文档中的404仍然使用的是http链接，导致部署到我的网站时（https），会有无法加载http资源问题，这里使用了另一个404书写方式，测试没有问题。 123456789101112131415---title: 404 Not Found：该页无法显示toc: falsecomments: false---&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;404&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageName=&quot;返回首页&quot; homePageUrl=&quot;../&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; NexT主题参考文档：NexT官方文档主题包含页面的一些配置，插件的使用，我这里主要配置了评论、次数统计、打赏等等，这些都在NexT的参考文档中可以找到，没有什么难度，自行查看。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
